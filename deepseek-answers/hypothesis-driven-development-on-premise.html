<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="stylesheet" href="../css/pico.min.css"></head><body><main class="container"><div class="ds-markdown ds-markdown--block" style="--ds-md-zoom: 1.143;"><p>Applying a <strong>hypothesis-driven approach</strong> to <strong>on-premise products</strong>
 (software installed and run on the customer's infrastructure) can be 
challenging due to the unique constraints of on-premise environments, 
such as limited access to user data, slower release cycles, and 
customer-specific configurations. However, with careful planning and 
adaptation, it is possible to implement this approach effectively. 
Hereâ€™s how:</p><hr><h3>1. <strong>Understand the Constraints of On-Premise Products</strong></h3><ul><li><p><strong>Limited Data Access</strong>: Unlike cloud-based products, you may not have direct access to usage data or analytics from customer environments.</p></li><li><p><strong>Custom Configurations</strong>: Each customer may have unique configurations, making it harder to generalize findings.</p></li><li><p><strong>Slower Release Cycles</strong>: On-premise software often has longer release cycles due to deployment and testing processes.</p></li><li><p><strong>Customer Control</strong>: Customers control when and how updates are applied, which can delay the rollout of new features or experiments.</p></li></ul><hr><h3>2. <strong>Adapt the Hypothesis-Driven Approach for On-Premise</strong></h3><h4><strong>A. Define Clear Hypotheses</strong></h4><ul><li><p>Focus on hypotheses that align with customer pain points or business goals.</p></li><li><p>Example:
 "If we add a feature to automate report generation, then customers will
 reduce manual effort by 20%, leading to higher satisfaction."</p></li></ul><h4><strong>B. Use Proxy Metrics</strong></h4><ul><li><p>Since direct access to customer data may be limited, use proxy metrics to measure outcomes. For example:</p><ul><li><p>Customer feedback during demos or workshops.</p></li><li><p>Support ticket trends (e.g., reduction in tickets related to a specific issue).</p></li><li><p>Surveys or interviews with users.</p></li></ul></li></ul><h4><strong>C. Leverage Beta Programs</strong></h4><ul><li><p>Work with a subset of customers in a <strong>beta program</strong> to test hypotheses. These customers can provide early feedback and usage data.</p></li><li><p>Example: Roll out a new feature to a few beta customers and measure its impact on their workflows.</p></li></ul><h4><strong>D. Build Prototypes and MVPs</strong></h4><ul><li><p>Develop lightweight prototypes or Minimum Viable Products (MVPs) to test hypotheses.</p></li><li><p>Use these prototypes in customer workshops or demos to gather feedback before committing to full development.</p></li></ul><h4><strong>E. Simulate On-Premise Environments</strong></h4><ul><li><p>Create internal environments that mimic customer setups to test hypotheses before deploying to actual customer systems.</p></li><li><p>Use tools like Docker or virtual machines to replicate customer configurations.</p></li></ul><h4><strong>F. Collaborate with Customers</strong></h4><ul><li><p>Engage closely with customers to understand their needs and validate hypotheses.</p></li><li><p>Conduct joint workshops, interviews, or design sprints to co-create solutions.</p></li></ul><hr><h3>3. <strong>Experiment Design for On-Premise Products</strong></h3><h4><strong>A. Feature Flags</strong></h4><ul><li><p>Use <strong>feature flags</strong> to enable or disable features in customer environments without requiring a full release.</p></li><li><p>This allows you to test hypotheses with specific customers or user groups.</p></li></ul><h4><strong>B. A/B Testing (Where Possible)</strong></h4><ul><li><p>If the product architecture allows, conduct A/B testing within customer environments.</p></li><li><p>Example: Deploy two versions of a feature to different user groups within the same customer organization and measure the impact.</p></li></ul><h4><strong>C. Feedback Loops</strong></h4><ul><li><p>Establish feedback loops with customers to gather qualitative and quantitative data.</p></li><li><p>Use tools like in-app feedback widgets, surveys, or regular check-ins.</p></li></ul><h4><strong>D. Logging and Analytics (Where Permitted)</strong></h4><ul><li><p>If customers allow, implement lightweight logging or analytics to collect usage data.</p></li><li><p>Ensure compliance with data privacy regulations and customer policies.</p></li></ul><hr><h3>4. <strong>Iterate Based on Feedback</strong></h3><ul><li><p>Use the feedback and data gathered from experiments to refine your hypotheses and solutions.</p></li><li><p>Communicate findings and improvements to customers to build trust and demonstrate value.</p></li></ul><hr><h3>5. <strong>Leverage Customer Success and Support Teams</strong></h3><ul><li><p>Collaborate with customer success and support teams to identify pain points and validate hypotheses.</p></li><li><p>These teams often have direct insights into customer challenges and can help prioritize experiments.</p></li></ul><hr><h3>6. <strong>Communicate the Value of Hypothesis-Driven Development</strong></h3><ul><li><p>Educate
 customers about the benefits of the hypothesis-driven approach, such as
 faster delivery of value and reduced risk of building unwanted 
features.</p></li><li><p>Highlight how their feedback directly shapes the product.</p></li></ul><hr><h3>Example: Applying Hypothesis-Driven Approach to an On-Premise Product</h3><p><strong>Problem</strong>: Customers are struggling with slow performance in a data processing module.</p><p><strong>Hypothesis</strong>:
 "If we optimize the data processing algorithm, then processing times 
will decrease by 30%, leading to higher customer satisfaction."</p><p><strong>Experiment</strong>:</p><ol start="1"><li><p>Develop an optimized algorithm and test it in an internal environment that simulates customer setups.</p></li><li><p>Deploy the optimized version to a few beta customers using feature flags.</p></li><li><p>Measure processing times and gather feedback from beta customers.</p></li></ol><p><strong>Outcome</strong>:</p><ul><li><p>If the hypothesis is validated, roll out the optimization to all customers in the next release.</p></li><li><p>If not, revisit the hypothesis and explore alternative solutions.</p></li></ul><hr><h3>Tools and Techniques for On-Premise Hypothesis Testing</h3><ol start="1"><li><p><strong>Feature Management Tools</strong>:</p><ul><li><p>Tools like LaunchDarkly or Split.io can help manage feature flags in on-premise environments.</p></li></ul></li><li><p><strong>Feedback Collection Tools</strong>:</p><ul><li><p>Use tools like SurveyMonkey, Typeform, or in-app feedback widgets to gather customer input.</p></li></ul></li><li><p><strong>Simulation Environments</strong>:</p><ul><li><p>Use virtualization tools (e.g., VMware, Docker) to replicate customer environments for testing.</p></li></ul></li><li><p><strong>Collaboration Platforms</strong>:</p><ul><li><p>Use platforms like Miro or MURAL for collaborative workshops with customers.</p></li></ul></li></ol><hr><h3>Challenges and Mitigations</h3><table><thead><tr><th><strong>Challenge</strong></th><th><strong>Mitigation</strong></th></tr></thead><tbody><tr><td>Limited access to customer data</td><td>Use proxy metrics, surveys, and customer interviews.</td></tr><tr><td>Slow release cycles</td><td>Leverage feature flags and beta programs to test hypotheses incrementally.</td></tr><tr><td>Customer-specific configurations</td><td>Simulate customer environments internally and collaborate closely with customers.</td></tr><tr><td>Resistance to change</td><td>Communicate the benefits of the hypothesis-driven approach to stakeholders.</td></tr></tbody></table><hr><h3>Conclusion</h3><p>Applying
 a hypothesis-driven approach to on-premise products requires adaptation
 to the unique constraints of on-premise environments. By focusing on 
clear hypotheses, leveraging beta programs, using feature flags, and 
collaborating closely with customers, you can effectively test and 
validate ideas. This approach not only reduces the risk of building 
unwanted features but also ensures that the product evolves to meet 
customer needs.</p></div></main></body></html>